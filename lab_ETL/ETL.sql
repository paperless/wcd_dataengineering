use warehouse wcd_wh1_diana;
USE DATABASE WCD_LAB;

-- populate STORE_DIM
/* for new stores, merge into the dimension table and set as active */
MERGE INTO WCD_LAB.WALMART_ANS.STORE_DIM t1
USING WALMART.STORE t2
ON t1.STORE_KEY = t2.STORE_KEY AND 
t1.STORE_NAME = t2.STORE_DESC AND 
t1.ADDR = t2.ADDR AND 
t1.CITY = t2.CITY AND 
t1.REGION = t2.REGION AND 
t1.CNTRY_CD = t2.CNTRY_CD AND 
t1.CNTRY_NM = t2.CNTRY_NM AND 
t1.POSTAL_ZIP_CD = t2.POSTAL_ZIP_CD AND 
t1.PROV_NAME = t2.PROV_STATE_DESC AND 
t1.PROV_CODE = t2.PROV_STATE_CD AND 
t1.STATUS_CODE = t2.STORE_TYPE_CD AND 
t1.STATUS_CD_NAME = t2.STORE_TYPE_DESC AND 
t1.MARKET_KEY = t2.MARKET_KEY AND 
T1.MARKET_NAME = t2.MARKET_NAME AND 
t1.SUBMARKET_KEY = t2.SUBMARKET_KEY AND 
t1.SUBMARKET_NAME = t2.SUBMARKET_NAME AND 
t1.LATITUDE = t2.LATITUDE AND 
t1.LONGITUDE = t2.LONGITUDE
WHEN NOT MATCHED THEN 
INSERT (
	t1.STORE_KEY,
	t1.STORE_NAME,
	t1.ADDR,
	t1.CITY,
	t1.REGION,
	t1.CNTRY_CD,
	t1.CNTRY_NM,
	t1.POSTAL_ZIP_CD,
	t1.PROV_NAME,
	t1.PROV_CODE,
	t1.MARKET_KEY,
	t1.MARKET_NAME,
	t1.SUBMARKET_KEY,
	t1.SUBMARKET_NAME,
	t1.LATITUDE,
	t1.LONGITUDE,
	t1.TLOG_ACTIVE_FLG,
	t1.START_DATE,
	t1.END_DATE	
)
VALUES ( 
	t2.STORE_KEY,
	t2.STORE_DESC,
	t2.ADDR,
	t2.CITY,
	t2.REGION,
	t2.CNTRY_CD,
	t2.CNTRY_NM,
	t2.POSTAL_ZIP_CD,
	t2.PROV_STATE_DESC,
	t2.PROV_STATE_CD,
	t2.MARKET_KEY,
	t2.MARKET_NAME,
	t2.SUBMARKET_KEY,
	t2.SUBMARKET_NAME,
	t2.LATITUDE,
	t2.LONGITUDE,
	TRUE ,
	CAST(current_timestamp AS date),
	to_date('9999-12-31')
);

/* for existing stores with changed information, set to inactive */
MERGE INTO WCD_LAB.WALMART_ANS.STORE_DIM t1
USING WCD_LAB.WALMART.STORE t2 
ON t1.STORE_KEY = t2.STORE_KEY AND 
	( t1.STORE_NAME != t2.STORE_DESC OR 
	t1.ADDR != t2.ADDR OR 
	t1.CITY != t2.CITY OR 
	t1.REGION != t2.REGION OR 
	t1.CNTRY_CD != t2.CNTRY_CD OR 
	t1.CNTRY_NM != t2.CNTRY_NM OR 
	t1.POSTAL_ZIP_CD != t2.POSTAL_ZIP_CD OR 
	t1.PROV_NAME != t2.PROV_STATE_DESC OR 
	t1.PROV_CODE != t2.PROV_STATE_CD OR 
	t1.STATUS_CODE != t2.STORE_TYPE_CD OR 
	t1.STATUS_CD_NAME != t2.STORE_TYPE_DESC OR 
	t1.MARKET_KEY != t2.MARKET_KEY OR 
	T1.MARKET_NAME != t2.MARKET_NAME OR 
	t1.SUBMARKET_KEY != t2.SUBMARKET_KEY OR 
	t1.SUBMARKET_NAME != t2.SUBMARKET_NAME OR 
	t1.LATITUDE != t2.LATITUDE OR 
	t1.LONGITUDE != t2.LONGITUDE
	)
WHEN MATCHED THEN UPDATE 
SET t1.TLOG_ACTIVE_FLG = FALSE ,
	t1.END_DATE = CAST(current_timestamp AS date);

-- populate PRODUCT_DIM ----------

MERGE INTO WCD_LAB.WALMART_ANS.PRODUCT_DIM trg
USING WCD_LAB.WALMART.PRODUCT src
ON trg.PROD_KEY = src.PROD_KEY
	AND trg.PROD_NAME = src.PROD_NAME
	AND trg.VOL = src.VOL
	AND trg.WGT = src.WGT
	AND trg.BRAND_NAME = src.BRAND_NAME
	AND trg.STATUS_CODE = src.STATUS_CODE
	AND trg.STATUS_CODE_NAME = src.STATUS_CODE_NAME
	AND trg.CATEGORY_KEY = src.CATEGORY_KEY
	AND trg.CATEGORY_NAME = src.CATEGORY_NAME
	AND trg.SUBCATEGORY_KEY = src.SUBCATEGORY_KEY
	AND trg.SUBCATEGORY_NAME = src.SUBCATEGORY_NAME
WHEN NOT MATCHED THEN 
INSERT 
(
	TRG.PROD_KEY ,
	TRG.PROD_NAME,
	TRG.VOL,
	TRG.WGT,
	TRG.BRAND_NAME,
	TRG.STATUS_CODE,
	TRG.STATUS_CODE_NAME,
	TRG.CATEGORY_KEY,
	TRG.CATEGORY_NAME,
	TRG.SUBCATEGORY_KEY,
	TRG.SUBCATEGORY_NAME,
	TRG.TLOG_ACTIVE_FLG, --here
	TRG.START_DATE,
	TRG.END_DATE
)
VALUES 
(
	src.PROD_KEY,
	src.PROD_NAME,
	src.VOL,
	src.WGT,
	src.BRAND_NAME,
	src.STATUS_CODE,
	src.STATUS_CODE_NAME,
	src.CATEGORY_KEY,
	src.CATEGORY_NAME,
	src.SUBCATEGORY_KEY,
	src.SUBCATEGORY_NAME,
	TRUE ,
	cast(current_timestamp AS date),
	NULL 
);

-- when information has changed 
MERGE INTO WCD_LAB.WALMART_ANS.PRODUCT_DIM t1
USING WCD_LAB.WALMART.PRODUCT t2 
ON t1.PROD_KEY = t2.PROD_KEY
	AND ( t2.PROD_NAME != t1.PROD_NAME
	OR t2.VOL != t1.VOL
	OR t2.WGT != t1.WGT
	OR t2.BRAND_NAME != t1.BRAND_NAME
	OR t2.STATUS_CODE != t1.STATUS_CODE
	OR t2.STATUS_CODE_NAME != t1.STATUS_CODE_NAME
	OR t2.CATEGORY_KEY != t1.CATEGORY_KEY
	OR t2.CATEGORY_NAME != t1.CATEGORY_NAME
	OR t2.SUBCATEGORY_KEY != t1.SUBCATEGORY_KEY
	OR t2.SUBCATEGORY_NAME != t1.SUBCATEGORY_NAME
	)
WHEN MATCHED THEN 
UPDATE 
SET t1.TLOG_ACTIVE_FLG = FALSE ,
	t1.END_DATE = CAST(current_timestamp AS date);

-- populate WCD_LAB.WALMART_ANS.SALES_INV_STORE_DY
--
SET LAST_DATE=(SELECT MAX(CAL_DT) FROM WCD_LAB.WALMART_ANS.SALES_INV_STORE_DY);

-- delete last day in daily fact table
DELETE FROM WCD_LAB.WALMART_ANS.SALES_INV_STORE_DY
WHERE CAL_DT >= NVL($LAST_DATE, to_date('1900-01-01'));

--CREATE TRANSIENT TABLE IF NOT EXISTS WALMART_ANS.INV_DY_STG
--(
--	CAL_DT,
--	STORE_KEY,
--	PROD_KEY
--)

INSERT INTO WCD_LAB.WALMART_ANS.SALES_INV_STORE_DY
(
	CAL_DT,
	STORE_KEY,
	PROD_KEY,
	SALES_QTY,
	SALES_PRICE,
	SALES_AMT,
	DISCOUNT,
	SALES_COST,
	SALES_MGRN,
	STOCK_ON_HAND_QTY,
	ORDERED_STOCK_QTY,
	OUT_OF_STOCK_FLG,
	IN_STOCK_FLG,
	LOW_STOCK_FLG
)
SELECT 
	TRANS_DT,
	s.STORE_KEY,
	s.PROD_KEY,
	SUM(SALES_QTY) ,
	AVG(SALES_PRICE) ,
	SUM(SALES_AMT) ,
	AVG(DISCOUNT),
	SUM(SALES_COST),
	SUM(SALES_MGRN),
	i.INVENTORY_ON_HAND_QTY ,
	i.INVENTORY_ON_ORDER_QTY ,
	CAST(i.OUT_OF_STOCK_FLG AS boolean),
	NOT i.OUT_OF_STOCK_FLG ,
	CASE 
		WHEN SUM(SALES_QTY) > i.INVENTORY_ON_HAND_QTY 
		THEN TRUE 
		ELSE FALSE 
	END	 
FROM WCD_LAB.WALMART.SALES s
	LEFT JOIN WCD_LAB.WALMART.INVENTORY i 
	ON s.TRANS_DT = i.CAL_DT 
	AND s.PROD_KEY = i.PROD_KEY 
	AND s.STORE_KEY = i.STORE_KEY 
WHERE s.TRANS_DT >= NVL($LAST_DATE, to_date('1900-01-01'))
GROUP BY 
	s.TRANS_DT,
	s.STORE_KEY ,
	s.PROD_KEY ,
	i.INVENTORY_ON_HAND_QTY ,
	i.INVENTORY_ON_ORDER_QTY ,
	i.OUT_OF_STOCK_FLG ;

-- create table with all years, weeks and prd + store combination
CREATE TRANSIENT TABLE IF NOT EXISTS WALMART_ANS.WEEK_STG
(
	YR_NUM integer,
	WK_NUM integer,
	LAST_DAY date,
	STORE_KEY number,
	PROD_KEY number
);
TRUNCATE TABLE WALMART_ANS.WEEK_STG;
INSERT INTO WALMART_ANS.WEEK_STG
SELECT 
	C.YR_NUM,
	C.WK_NUM,
	max(I.CAL_DT),
	I.STORE_KEY ,
	I.PROD_KEY  
FROM WCD_LAB.WALMART.CALENDAR C JOIN 
	WCD_LAB.WALMART.INVENTORY I ON C.CAL_DT = I.CAL_DT 
GROUP BY  
	YR_NUM,
	WK_NUM,
	I.STORE_KEY ,
	I.PROD_KEY ;
-- create table to hold the inventory levels on the last day of each week
CREATE TRANSIENT TABLE IF NOT EXISTS walmart_ans.wkly_last_day_inv
(
	YR_NUM integer,
	WK_NUM integer,
	LAST_DAY date,
	STORE_KEY number,
	PROD_KEY number,
	LD_INV_ON_HAND_QTY number(38,2),
	LD_INV_ON_ORDER_QTY number(38,2)
);
TRUNCATE TABLE IF EXISTS walmart_ans.wkly_last_day_inv;
INSERT INTO walmart_ans.wkly_last_day_inv
SELECT 
t1.YR_NUM,
t1.WK_NUM,
t1.LAST_DAY,
t1.STORE_KEY ,
t1.PROD_KEY,
I.INVENTORY_ON_HAND_QTY ,
I.INVENTORY_ON_ORDER_QTY 
FROM WALMART_ANS.WEEK_STG t1
	JOIN WCD_LAB.WALMART.INVENTORY I 
	ON t1.LAST_DAY = I.CAL_DT 
	AND T1.STORE_KEY = I.STORE_KEY 
	AND t1.PROD_KEY = I.PROD_KEY ;

-- populate weekly fact table
SET (LATEST_YEAR, LATEST_WK) = (SELECT MAX(YR_NUM) , MAX(WK_NUM) FROM WCD_LAB.WALMART_ANS.SALES_INV_STORE_WK);
DELETE FROM WCD_LAB.WALMART_ANS.SALES_INV_STORE_WK
WHERE YR_NUM>=$LATEST_YEAR AND WK_NUM>=$LATEST_WK;

SELECT $LATEST_YEAR, $LATEST_WK;
--TRUNCATE TABLE WCD_LAB.WALMART_ANS.SALES_INV_STORE_WK;
INSERT INTO WCD_LAB.WALMART_ANS.SALES_INV_STORE_WK
(
	YR_NUM,
	WK_NUM,
	PROD_KEY,
	STORE_KEY,
	WK_SALES_QTY,
	AVG_SALES_PRICE,
	WK_SALES_AMT,
	WK_DISCOUNT,
	WK_SALES_COST,
	WK_SALES_MGRN,
	EOP_STOCK_ON_HAND_QTY,
	EOP_ORDERED_STOCK_QTY,
	OUT_OF_STOCK_TIMES,
	IN_STOCK_TIMES,
	LOW_STOCK_TIMES
)
SELECT 
	C.YEAR_NUM AS yr_num, 
	C.WEEK_NUM AS wk_num, 
	dy.PROD_KEY , 
	dy.STORE_KEY ,
	sum(dy.SALES_QTY) AS wk_sales_qty,
	AVG(dy.SALES_PRICE) AS avg_sales_price,
	SUM(dy.SALES_AMT) AS wk_sales_amt,
	AVG(dy.DISCOUNT) AS wk_discount,
	SUM(dy.SALES_COST) AS wk_sales_cost,
	SUM(dy.SALES_MGRN) AS wk_sales_mgrn,
	L.LD_INV_ON_HAND_QTY AS eop_stock_on_hand_qty,
	L.LD_INV_ON_ORDER_QTY AS eop_ordered_stock_qty,
	COUNT(dy.OUT_OF_STOCK_FLG) AS out_of_stock_times,
	COUNT(dy.IN_STOCK_FLG) AS in_stock_times,
	COUNT(dy.LOW_STOCK_FLG) AS low_stock_times
FROM WCD_LAB.WALMART_ANS.SALES_INV_STORE_DY dy 
	LEFT JOIN WCD_LAB.WALMART_ANS.CALENDAR_DIM C 
	ON dy.CAL_DT = c.CAL_DT 
	LEFT JOIN WCD_LAB.WALMART_ANS.WKLY_LAST_DAY_INV L 
	ON dy.STORE_KEY = L.STORE_KEY 
		AND dy.PROD_KEY = L.PROD_KEY 
		AND C.YEAR_NUM = L.YR_NUM 
		AND C.WEEK_NUM = L.WK_NUM 
WHERE C.YEAR_NUM >= nvl($LATEST_YEAR , 1900)
	AND C.WEEK_NUM >= nvl($LATEST_WK , 1)
GROUP BY 
	C.YEAR_NUM , 
	C.WEEK_NUM , 
	dy.PROD_KEY , 
	dy.STORE_KEY,
	L.LD_INV_ON_HAND_QTY ,
	L.LD_INV_ON_ORDER_QTY;

